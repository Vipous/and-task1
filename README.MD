# Задание к занятиям 1-4

Необходимо реализовать программу на Kotlin, которая будет соответствовать следующим требованиям:

## 1. Генерация объектов

Реализовать функцию, которая создаёт список объектов разных классов. Пример: Генерация списка животных различных типов (кошки, собаки и т.д.). Подсказка: можно использовать рандомизаторы (.random и прочие функции).

## 2. Фильтрация и преобразование

Реализовать функцию для фильтрации или преобразования списка объектов. Пример: Выбор животных в определённом состоянии (например, только спящих) или преобразование списка в другую структуру данных (например, Map по состояниям животных).

## 3. Состояние через enum/sealed class

Каждое животное должно иметь поле, описывающее его состояние. Это состояние необходимо реализовать через enum/sealed class. Пример: Состояния животных - спит, ест (что ест - enum возможных вариантов еды), гуляет (где гуляет - enum возможных мест).

## 4. Работа с ошибками

Если у животного отсутствует состояние, выбрасывать исключение (Exception).

## 5. Использование Kotlin-функциональности
Программа должна демонстрировать использование:

- extension-функций
- классов: data, sealed, enum, abstract
- дженериков для универсальности функций и структур данных
- попробовать найти применение ленивому делигату "by lazy"

## 6. Вывод результатов

Все результаты выполнения функций (генерация, фильтрация, преобразование и т.д.) должны выводиться в консоль.

## Nice-to-have вещи (рекомендация)

- попробовать разделить функционал на отдельные осознанные сущности, стараться не писать все в одном файле;
- давать названиям функций, классов и переменных читаемые нейминги :)
- не забывать использовать шорткат форматирования в IDEA, чтобы были выравнивания кода.

# Решение

## 1. Генерация
Программа генерирует юниты из игры StarCraft

Три расы `Protos`, `Terran` и `Zerg` которые представлены абстрактными классами и 
от наследованы от общего абстрактного класса `StarUnit` - в котором содержатся общие свойства: name, id и state

- `name` - передается в конструкторе
- `id` - лениво определяется уникальным ид UUID
- `state` - мутабельное свойство, определяет состояние юнита, также observable - печатает в консоль изменения состояния

Для каждой расы 5 видов юнитов

Для генерации используется ф-ция высшего порядка `generateUnits`, 
все юниты получают
- случайно состояние реализованное в функции `randomState`
- случайное имя реализованное в высшем свойстве `randomName`

## 2 Фильтрация

Функции `filterByState`, `groupByState` реализованы как extension для `List<StarUnit>`
- `filterByState` может фильтровать по предикату. В задании используется `{it is UnitState.Stop}` - 
т.е. отбирается все юниты в состоянии Stop, но может быть и сложное условие
- `groupByState` выполняет группировку по Имени состояния, причем если состояние Undefined может выбросить ошибку
  (регулируется флагом `throwIfUndefined`)

## 3 Состояние через enum/sealed class

Состояния реализованы через `sealed interface UnitState`. Существуют состояния со свойствами и без.
- `Patrol` патрулирование между двумя точками реализована 
`lasy` свойство `distance` которая подсчитывает расстояние между точками по прямой
- `Hold`(держать позицию) описано enum `Direction` - которое определяем в какую сторону повернут юнит.

## 4. Работа с ошибками

Вызов `List<StarUnit>.groupByState(true)` выбросит ошибку если состояние `UnitState.Undefined`

## Использование Kotlin-функциональности

- `abstract class StarUnit`
- `sealed interface UnitState`
- `data class Point` и др
- `enum class Direction`
- `typealias Line`
- extension `StarUnit.describe()`
- extension `List<StarUnit>.describe()`
- companion object `Point.random`
- generic `inline fun <reified T : StarUnit> List<StarUnit>.filterByType(): List<T>`
- generic `quad<T: StarUnit>`

## 6 Вывод результатов

Для вывода информации о юнитах создана extension функция `StarUnit.describe()`, 
которая возвращает строку с кратким описанием



